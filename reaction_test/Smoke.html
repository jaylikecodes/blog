<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Smoke Game</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>

  <!-- Language handling script -->
  <script type="module">
    import { translations } from './js/translations.js';
    
    // Handle language from URL parameter
    function getLanguageFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const langParam = urlParams.get('lang');
      return langParam && (langParam === 'en' || langParam === 'ko') ? langParam : 'ko'; // Default to Korean
    }

    // Initialize language
    function initializeLanguage() {
      const lang = getLanguageFromURL();
      document.documentElement.lang = lang;
      
      // Create global translation object for other modules to use
      window.gameTranslations = {
        translations: translations,
        currentLang: lang,
        
        // Get text for current language
        getText: function(key) {
          return this.translations[this.currentLang][key] || key;
        },
        
        // Change language
        changeLanguage: function(lang) {
          this.currentLang = lang;
          document.documentElement.lang = lang;
          
          // Sync with parent if in iframe
          if (window.parent && window.parent !== window) {
            try {
              if (window.parent.changeLanguage) {
                window.parent.changeLanguage(lang);
              }
            } catch (e) {
              console.log('Could not sync language with parent window', e);
            }
          }
        },
        
        // Update all text content
        updateAllText: function() {
          document.querySelectorAll('[data-text]').forEach(element => {
            const textKey = element.getAttribute('data-text');
            if (this.translations[this.currentLang] && this.translations[this.currentLang][textKey]) {
              element.textContent = this.translations[this.currentLang][textKey];
            }
          });
          
          // Update language button states
          document.querySelectorAll('.lang-btn').forEach(btn => {
            if (btn.getAttribute('data-lang') === this.currentLang) {
              btn.classList.add('active');
            } else {
              btn.classList.remove('active');
            }
          });
        }
      };
      
      // Update all text content for initial rendering
      window.gameTranslations.updateAllText();
      
      // Set up language buttons
      document.querySelectorAll('.lang-btn').forEach(button => {
        button.addEventListener('click', function() {
          const lang = this.getAttribute('data-lang');
          window.gameTranslations.changeLanguage(lang);
          window.gameTranslations.updateAllText();
          localStorage.setItem('selected_language', lang);
        });
      });
    }
    
    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      initializeLanguage();
    });
    
    // Call initialize immediately if document already loaded
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      initializeLanguage();
    }
  </script>
</head>
<body>
  <div class="language-selector">
  
  <div class="game-container">
    <div class="game-area">
      <h1><span data-text="smoke-game-title">Smoke Game</span></h1>
      <div id="game-canvas"></div>
      
      <div class="game-instructions">
        <p data-text="smoke-game-desc">Use arrow keys to move and attack. Defeat the enemy before your health runs out!</p>
        <ul>
          <li data-text="smoke-instruction-1">Use left/right arrow keys to move</li>
          <li data-text="smoke-instruction-2">Press space bar to attack</li>
          <li data-text="smoke-instruction-3">Stay close to the enemy to deal damage</li>
          <li data-text="smoke-instruction-4">Press Enter to restart the game after game over</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
  // Global variables
  let player;
  let enemy;
  let smokeParticles = [];
  let gameState = 'start'; // 'start', 'playing', 'gameOver'
  let score = 0;

  // Smoke effect control
  let smokeEmissionDuration = 120; // Emit smoke for ~2 seconds (120 frames at 60fps)
  let smokeEmissionTimer = 0;
  let playerDeathX; // X-coordinate where player died

// Player and Enemy y-offset from bottom of screen
const yFloorOffset = 5;

function setup() {
  createCanvas(windowWidth, windowHeight);
  // Set color mode to HSB (Hue, Saturation, Brightness, Alpha)
  // Hue ranges from 0 to 360, Sat/Bri from 0 to 100, Alpha from 0 to 1
  colorMode(HSB, 360, 100, 100, 1);
  
  player = {}; // Placeholder, properly initialized on game start
  enemy = {};  // Placeholder
}

function initializePlayer() {
  player = {
    x: width / 4,
    y: height - (30 / 2) - yFloorOffset, // 30 is player size
    size: 30,
    speed: 5,
    hp: 100,
    maxHp: 100,
    attackPower: 20,
    attackRange: 50, // Radius of attack from player center
    attackCooldown: 30, // frames
    lastAttackFrame: -Infinity, // Allow immediate first attack
    isAttacking: false,
    attackAnimFrames: 10 // How long attack visual lasts
  };
}

function initializeEnemy() {
  let enemySize = 40;
  enemy = {
    x: (width * 3) / 4,
    y: height - (enemySize / 2) - yFloorOffset,
    size: enemySize,
    speed: 1.5,
    hp: 150,
    maxHp: 150,
    attackPower: 10,
    attackRange: 45, // Max distance from enemy center to player center for attack
    attackCooldown: 60, // frames
    lastAttackFrame: -Infinity // Allow immediate first attack
  };
}

function resetGame() {
  score = 0;
  initializePlayer();
  initializeEnemy();
  smokeParticles = []; // Clear any existing smoke particles
  smokeEmissionTimer = 0; // Reset smoke emission state
  gameState = 'playing';
}

// Main p5.js draw function
function draw() {
  let bgHue = (frameCount * 0.2) % 360;

  if (gameState === 'start') {
    background(bgHue, 70, 80); // Dynamic vibrant background
    textAlign(CENTER, CENTER);
    fill(0, 0, 100); // White text using HSB (Hue ignored, Sat=0, Bri=100)
    textSize(48);
    text("Simple Combat Game", width / 2, height / 3);
    textSize(24);
    text("Arrow Keys or A/D to Move", width / 2, height / 2);
    text("SPACE to Attack", width / 2, height / 2 + 40);
    textSize(32);
    text("Press ENTER to Start", width / 2, height / 2 + 100);
  } else if (gameState === 'playing') {
    background(220, 30, 20); // Dark, desaturated blue background for gameplay

    handleInput();
    updatePlayer();
    updateEnemy();
    
    drawPlayer();
    drawEnemy();
    drawUI();

    if (player.hp <= 0) {
      gameState = 'gameOver';
      playerDeathX = player.x; // Store X position for smoke origin
      smokeEmissionTimer = 0; // Start smoke emission sequence
    }
    if (enemy.hp <= 0) {
      score += 100;
      // Respawn enemy, making it slightly stronger
      initializeEnemy(); // Resets HP, position etc.
      enemy.x = random(width * 0.1, width * 0.9); // Randomize respawn x
      enemy.y = height - (enemy.size / 2) - yFloorOffset; // Ensure y is correct
      enemy.maxHp += score / 10; // Increase max HP based on score
      enemy.hp = enemy.maxHp;
    }

  } else if (gameState === 'gameOver') {
    background(0, 70, 50); // Dark red background for game over
    
    // Handle smoke emission from canvas floor below player's death position
    if (smokeEmissionTimer < smokeEmissionDuration) {
      if (frameCount % 3 === 0) { // Emit particles every 3 frames
        for (let i = 0; i < 2; i++) { // Emit 2 particles at a time
          smokeParticles.push(new SmokeParticle(playerDeathX, height));
        }
      }
      smokeEmissionTimer++;
    }

    // Update and draw all smoke particles
    for (let i = smokeParticles.length - 1; i >= 0; i--) {
      smokeParticles[i].update();
      smokeParticles[i].display();
      if (smokeParticles[i].isDead()) {
        smokeParticles.splice(i, 1);
      }
    }

    textAlign(CENTER, CENTER);
    fill(0, 0, 100); // White text
    textSize(64);
    text("GAME OVER", width / 2, height / 3);
    textSize(32);
    text("Score: " + score, width / 2, height / 2);
    
    if (smokeEmissionTimer >= smokeEmissionDuration && smokeParticles.length < 15) {
      textSize(24);
      text("Press R to Restart", width / 2, height / 2 + 80);
    }
  }
}

function handleInput() {
  if (keyIsDown(LEFT_ARROW) || keyIsDown(65)) { // 65 is 'A'
    player.x -= player.speed;
  }
  if (keyIsDown(RIGHT_ARROW) || keyIsDown(68)) { // 68 is 'D'
    player.x += player.speed;
  }
  player.x = constrain(player.x, player.size / 2, width - player.size / 2);

  if (keyIsDown(32) && frameCount > player.lastAttackFrame + player.attackCooldown) {
    player.isAttacking = true;
    player.lastAttackFrame = frameCount;
    
    let d = dist(player.x, player.y, enemy.x, enemy.y);
    if (d < player.attackRange + enemy.size / 2) { // Hit if enemy center is within player attack range
      enemy.hp -= player.attackPower;
    }
  }
}

function updatePlayer() {
  if (player.isAttacking && frameCount > player.lastAttackFrame + player.attackAnimFrames) {
    player.isAttacking = false;
  }
}

function updateEnemy() {
  if (abs(player.x - enemy.x) > enemy.size / 4) { 
     if (player.x < enemy.x) {
        enemy.x -= enemy.speed;
     } else {
        enemy.x += enemy.speed;
     }
  }
  enemy.x = constrain(enemy.x, enemy.size / 2, width - enemy.size / 2);

  let d = dist(player.x, player.y, enemy.x, enemy.y);
  if (d < enemy.attackRange + player.size / 2 && frameCount > enemy.lastAttackFrame + enemy.attackCooldown) {
    player.hp -= enemy.attackPower;
    enemy.lastAttackFrame = frameCount;
  }
}

function drawPlayer() {
  fill(120, 80, 90); // Greenish (HSB)
  ellipse(player.x, player.y, player.size, player.size);

  if (player.isAttacking) {
    fill(0, 0, 100, 0.3); // Semi-transparent white attack indicator
    ellipse(player.x, player.y, player.attackRange * 2, player.attackRange * 2);
  }
  
  drawHealthBar(player.x - player.size / 2, player.y - player.size / 2 - 15, player.size, 8, player.hp, player.maxHp);
}

function drawEnemy() {
  fill(0, 80, 90); // Reddish (HSB)
  ellipse(enemy.x, enemy.y, enemy.size, enemy.size);
  
  drawHealthBar(enemy.x - enemy.size / 2, enemy.y - enemy.size / 2 - 15, enemy.size, 8, enemy.hp, enemy.maxHp);
}

function drawHealthBar(x, y, w, h, currentHp, maxHp) {
  noStroke();
  fill(0, 0, 20); // Dark background for health bar
  rect(x, y, w, h);
  
  let hpRatio = constrain(currentHp / maxHp, 0, 1);
  fill(100, 90, 80); // Bright Green for health
  if (hpRatio > 0) {
    rect(x, y, w * hpRatio, h);
  }
}

function drawUI() {
  fill(0, 0, 100); // White text
  textSize(20);
  textAlign(LEFT, TOP);
  text("Score: " + score, 10, 10);
}

function keyPressed() {
  if (gameState === 'start' && keyCode === ENTER) {
    resetGame();
  } else if (gameState === 'gameOver') {
    if (smokeEmissionTimer >= smokeEmissionDuration && smokeParticles.length < 15) {
      if (key === 'r' || key === 'R') {
        resetGame();
      }
    }
  }
}

class SmokeParticle {
  constructor(originX, originY) {
    this.x = originX + random(-15, 15); 
    this.y = originY;                   
    this.vx = random(-0.4, 0.4);        
    this.vy = random(-0.7, -2.2);       

    this.initialAlpha = random(0.4, 0.7); 
    this.alpha = this.initialAlpha;

    this.size = random(15, 40);         
    this.initialSize = this.size;

    this.lifespan = 70 + floor(random(50)); 
    this.age = 0;

    this.hue = 0; 
    this.saturation = 0; 
    this.brightness = random(15, 45); 
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;

    this.vy *= 0.97; 
    this.vx *= 0.99; 

    this.age++;
    let lifeProgress = this.age / this.lifespan;

    this.alpha = this.initialAlpha * (1 - lifeProgress);
    this.size = this.initialSize * (0.3 + 1.0 * sin(PI * lifeProgress));
    this.size = max(0, this.size); 
  }

  isDead() {
    return this.alpha <= 0.01 || this.age >= this.lifespan || this.y < -this.size;
  }

  display() {
    noStroke();
    fill(this.hue, this.saturation, this.brightness, this.alpha);
    ellipse(this.x, this.y, this.size, this.size);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  if (gameState === 'playing' || gameState === 'gameOver') {
    if (player && player.size) { 
        player.y = height - (player.size / 2) - yFloorOffset;
        player.x = constrain(player.x, player.size / 2, width - player.size / 2);
    }
    if (enemy && enemy.size) { 
        enemy.y = height - (enemy.size / 2) - yFloorOffset;
        enemy.x = constrain(enemy.x, enemy.size / 2, width - enemy.size / 2);
    }
  }
}

// Create p5 instance in the game-canvas div
new p5((p) => {
  // Assign the p5 instance methods to the global scope
  window.setup = function() { setup(); };
  window.draw = function() { draw(); };
  window.keyPressed = function() { keyPressed(); };
  window.windowResized = function() { windowResized(); };
}, 'game-canvas');
